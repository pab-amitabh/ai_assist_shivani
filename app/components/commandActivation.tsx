'use client'

import { useState, useEffect, useCallback, useRef } from 'react';
import { useReactMediaRecorder } from "react-media-recorder-2";
import { start } from 'repl';
import { signIn, useSession } from "next-auth/react";
import ChatHistory from './ChatHistory';
import LoadingSpinner from './LoadingSpinner';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm'
import { decode } from 'punycode';
import { stringify } from 'querystring';
import SourceLink from './SourceLink';
export default function CommandActivation() {
    const [isListening, setIsListening] = useState(false);
    const [message, setMessage] = useState(false);
    const [audioBlob, setAudioBlob] = useState(null);
    const [isRecording, setIsRecording] = useState(false);
    const recognitionRef = useRef<null | any>(null);
    const [LLMResponse, setLLMResponse] = useState("");
    const [sendDisabled,setSendDisabled] = useState(false);
    const [rating,setRating] = useState(null);
    const [AIResponse,setAIResponse] = useState(false)


    // START OF 2022 Code *********************************************************************************************
    interface Chat {
        id: string,
        messages: Message[],
        userId: string,
    }

    interface Message {
        content: string;
        sender: string;
        messageType: string;
        id: string;
        rating: number;
        reviewComments: string;
        commentAddedAt?: Date | null
    } 
    

    const { data : session, status } = useSession();
    const [input, setInput] = useState("");
    // const [currentChat, setCurrentChat] = useState<string[]>(["Hello, I am PolicyAdvisor AI Assitant. What can I help you with?"]);
    const [currentChat, setCurrentChat] = useState<{ 
        message: string;
        sender: string;
        messageType: string;
        messageId: string;
        rating: number;
        reviewComments: string;
        commentAddedAt?: Date | null
    }[]>([{ message: "Hello, I am PolicyAdvisor AI Assistant. What can I help you with?", sender: "AI", messageType: "ANSWER", messageId: "", rating: -1, reviewComments: "", commentAddedAt: null }]);
    
    
    const [loading, setLoading] = useState<boolean>(false);
    const [chatHistory, setChatHistory] = useState<Chat[]>([]);
    const [currChatId, setCurrChatId] = useState<string>("");
    const [llmDone, setLlmDone] = useState<boolean>(false);
    const [commentMessage,setCommentMessage] = useState<{[key:string]:string}>({})
    let loadingVar = false;
    const currentChatRef = useRef<HTMLDivElement | null>(null);

    const currentChatArrayRef = useRef(currentChat);

    // Update currentChatRef to latest currentChat
    useEffect(() => {
    currentChatArrayRef.current = currentChat;
    }, [currentChat]);
    
    // Scroll to bottom of chat when new message is added
    useEffect(() => {
        if (currentChatRef.current) {
            currentChatRef.current.scrollIntoView({ behavior: "smooth" });
        }
    }, [currentChat])


    // updates chatHistory when a new LLmResponse is received
    useEffect(() => {
        if (llmDone) {
            setMessage(false);
            setLoading(false);

            // const normalizedLLMResponse = LLMResponse.toLowerCase()
            //         .replace(/\s+/g, " ") // Normalize spaces and newlines
            //         .replace(/\*/g, "") // Remove markdown bold formatting
            //         .replace(/<b>/g, "").replace(/<\/b>/g, ""); // Remove <b> HTML tags
            
            // console.log("Normalized Response:", normalizedLLMResponse);
            // const generatedByAI=normalizedLLMResponse.includes("response is generated by openai");

            const updateChat = async (newMessage: string, messageType: string, sender: string, questionId: string | null,isResolved: boolean ) => {
                const response= await fetch("/api/updateChat", {
                    method: 'POST',
                    headers: {
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify({ chatId: currChatId, message: newMessage,messageType: messageType,sender: sender, questionId:questionId, isResolved: isResolved})
                })
                const data=await response.json();
                return data.question_id;
            }

            const updateBothChats = async () => {
                if (currentChat.length < 2) return; // Prevent accessing an out-of-bounds index
            
                const lastUserMessage = currentChat[currentChat.length - 2]; // Get the last user message
                const question_id = await updateChat(lastUserMessage.message, 'QUESTION', 'USER', null, false);
            
                if (AIResponse) {
                    const answer_id = await updateChat(LLMResponse, 'ANSWER', 'AI', question_id, true);
                    
                    // Update AI message with answer_id in currentChat
                    setCurrentChat((state) =>
                        state.map((msg, idx) =>
                            idx === state.length - 1 ? { ...msg, messageId: answer_id } : msg
                        )
                    );
                } else {
                    const answer_id = await updateChat(LLMResponse, 'ANSWER', 'AI', question_id, false);
                    
                    // Update AI message with answer_id in currentChat
                    setCurrentChat((state) =>
                        state.map((msg, idx) =>
                            idx === state.length - 1 ? { ...msg, messageId: answer_id } : msg
                        )
                    );
                }
            };
            
            updateBothChats();
            setLlmDone(false);
            setAIResponse(false);
            
        }
    }, [llmDone])

    async function callLLM(question: string) {
        if (loading || loadingVar) {
			return;
		}
		if (!question) {
			alert("Please input a question");
			return;
		}
        setInput("");
		console.log("current chat in getResponse: ", currentChat)
		// await setCurrentChat((state) => {
		// 	const newState = [...state];
		// 	newState.push(question);
		// 	return newState;
		// })
        await setCurrentChat((state) => [
            ...state,
            {
                message: question,
                sender: "USER",
                messageType: "QUESTION",
                messageId: "",
                rating: -1,
                reviewComments: "",
                commentAddedAt: null
            }
        ]);
        
        console.log('question::',question)
		console.log("currentChat after pushing question", currentChat)
		setLoading(true);
        setSendDisabled(true);
        loadingVar = true;
		// const question = input.trim()

		try {
			// https://us-central1-fir-test-962b5.cloudfunctions.net/app/chat
			const response = await fetch('/api/getLLMResponse', {
                method: 'POST',
                body: JSON.stringify({query: question, chatHistory: currentChatArrayRef.current}),
                headers: {
                    'Content-Type': 'application/json'
                }
            });

            // @ts-ignore
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let accumulated = '';
            let sources = ""
            let first = true;
            while (true) {
                const { done, value } = await reader.read();
                if (done) {
                    const normalizedLLMResponse = accumulated.toLowerCase()
                    .replace(/\s+/g, " ") // Normalize spaces and newlines
                    .replace(/\*/g, "") // Remove markdown bold formatting
                    .replace(/<b>/g, "").replace(/<\/b>/g, ""); // Remove <b> HTML tags
            
                    if (!normalizedLLMResponse.includes("response is generated by openai")){
                        accumulated += "  \n  \nSources:  \n" + sources 
                        setCurrentChat((state) => 
                            state.map((msg, idx) =>
                                idx === state.length - 1 
                                    ? { ...msg, message: msg.message + (sources !== '' ? "\n\nSources:\n": '' ) + sources }
                                    : msg
                            )
                        );
                    } else {
                        setAIResponse(true);
                    }

                    setLoading(false);
                    setLLMResponse(accumulated);
                    setLlmDone(true);
                    loadingVar = false;
                    setSendDisabled(false);
                    break;
                }

                // if (first) {
                //     setCurrentChat((state) => {
                //         const newState = [...state];
                //         newState.push("");
                //         return newState;
                //     })
                //     first = false;
                // }
                
                if (first) {
                    setCurrentChat((state) => [
                        ...state,
                        { message: "", sender: "AI", messageType: "ANSWER", messageId: '', rating:-1, reviewComments: "", commentAddedAt: null } // Temporary ID
                    ]);
                    first = false;
                }
                


                const chunkText = decoder.decode(value, { stream: true }).toString();
                // console.log("chunkText: ", chunkText);
                if (chunkText.includes("Source by LLM:")) {
                    // console.log("in chunkText.includes");
                    // console.log("chunkText.replaceAll: ", chunkText.replaceAll("Source by LLM:", ""));
                    sources += chunkText.replaceAll("Source by LLM:", "");
                } else if (chunkText.includes("End of Source by LLM")) {
                    let endIndex = chunkText.indexOf("End of Source by LLM");
                    sources += chunkText.slice(0, endIndex + 20);
                    accumulated += chunkText.slice(endIndex + 20);
                    console.log("accumulated added with end of sources: ", chunkText.slice(endIndex + 20));
                    setCurrentChat((state) => {
                        return state.map((msg, idx) =>
                            idx === state.length - 1 ? { ...msg, message: msg.message + chunkText } : msg
                        );
                    });
                } 
                else {
                    accumulated += chunkText;
                    // console.log("chunkText: ", chunkText);
                    setCurrentChat((state) => {
                        return state.map((msg, idx) =>
                            idx === state.length - 1 ? { ...msg, message: msg.message + chunkText } : msg
                        );
                    });
                }
            }
            
			
			
		} catch (error) {
			console.log("Error", error);
			setLoading(false);
		}


    }

    async function getResponse(event:any) {
		// console.log(input);
		event.preventDefault();
        callLLM(input);
	}

    // END OF 2022 CODE ********************************************************************************************    

    // useEffect(() => {
    //     console.log("isListening Changed", isListening)
    // }, [isListening]) 
    
    const startListening = async () => {
        if (!('webkitSpeechRecognition' in window)) {
            alert("Web Speech API is not supported on this browser. Try Chrome!");
            return;
        }

        const recognition = new (window as any).webkitSpeechRecognition();
        recognition.continuous = true;
        recognition.interimResults = true;
        recognition.lang = "en-US";

        recognitionRef.current = recognition;

        recognition.onstart = () => {
            setIsListening(true);
            setMessage(true);
            console.log("Recognition started inside .onStart func")
        };

        recognition.onresult = async (event: any) => {
            let finalTranscript = '';
            for (let i = 0; i < event.results.length; i++) {
                const transcript = event.results[i][0].transcript;
                if (event.results[i].isFinal) {
                    finalTranscript += transcript;
                }
            }
            finalTranscript = finalTranscript.split(",").join("").trim();
            finalTranscript = finalTranscript.toLowerCase();

            const replacementPhrases = ["high advisor", "hey advisor", "hi advisor", "high adviser", "hey adviser", "hi adviser", "he advisor", "he adviser", "head visor", "heyadvisor", "heyadviser", "hair advisor", "pay advisor", "pay adviser", "head riser",
                                        "high policy advisor", "hey policy advisor", "hi policy advisor", "high policy adviser", "hey policy adviser", "hi policy adviser"];

            for (let i = 0; i < replacementPhrases.length; i++) {
                finalTranscript = finalTranscript.replaceAll(replacementPhrases[i], "hi advisor");
            }
            // console.log(finalTranscript.toLowerCase());
            // console.log("New event")
            // console.log(event)
            // const transcript = event.results[0][0].transcript.trim();
            // console.log(finalTranscript.toLowerCase())

            if (finalTranscript.includes("hi advisor") && finalTranscript.includes("thank you")) {

                const lowercaseTranscript = finalTranscript.toLowerCase();
                const startIndex = lowercaseTranscript.lastIndexOf("hi advisor");
                const endIndex = lowercaseTranscript.lastIndexOf("thank you");
                
                
                if (startIndex < endIndex) {
                    const extractedText = finalTranscript.slice(startIndex + 10, endIndex);
                    console.log(extractedText)
                    if (extractedText === "") {
                        console.log("Empty string")
                        recognition.stop()
                    }
                    setMessage(false)
                    callLLM(extractedText);
                } 
                
                recognition.stop();
                
            } else if (finalTranscript.includes("hi advisor")) {
                const lowercaseTranscript = finalTranscript.toLowerCase();
                const startIndex = lowercaseTranscript.lastIndexOf("hi advisor");
                const extractedText = finalTranscript.slice(startIndex + 10);
                setInput(extractedText);
                
            }
            else {
                // setMessage("Phrase not recognized");
                console.log(finalTranscript.toLowerCase(), ": is not the phrase")
            }
            // setIsListening(false);
        };

        recognition.onerror = (event: any) => {
            console.error(event.error);
            setIsListening(false);
            recognition.stop();
        };

        recognition.onend = () => {
            setIsListening(false);
            startListening();
        }
        
        recognition.start();
        
        console.log("Recognition started")
    }
    
    const stopListening = () => {
        if (recognitionRef.current) {
            recognitionRef.current.stop();
            setMessage(false);
            setIsListening(false);
            recognitionRef.current = null;
        }
    } 

    function extractSources(message: string) {
        // console.log("message in extractSources: ", message)
        const sourcesStartIndex = message.indexOf("\nSources:");
        
        if (sourcesStartIndex === -1) {
          return []; // No sources found
        }
      
        const sourcesPart = message.slice(sourcesStartIndex + "\nSources:".length);
        // console.log("sourcesPart: ", sourcesPart)
        const sources = sourcesPart.split("End of Source by LLM")
                        .map(line => line.trim())
                        .filter(line => line.startsWith("* ["))
                        .map(line => {
                            // @ts-ignore
                            const matches = line.match(/\* \[(.*?)\]\((.*?)\)/s);
                            return matches ? { text: matches[1], url: matches[2] } : {};
                        })
                        
          
        //   .filter(line => line.startsWith("* ["))
        //   .map(line => {
            // const matches = line.match(/\* \[(.*?)\]\((.*?)\)/);
        //     return matches ? { text: matches[1], url: matches[2] } : null;
        //   })
        //   .filter(source => source !== null);
        
        // console.log("sources: ", sources)
        return sources;
      }

    const updateRating = async (message_id:any, rating:any) => {
        const response= await fetch("/api/updateRating", {
            method: 'POST',
            headers: {
                "Content-Type": "application/json",
            },
            body: JSON.stringify({message_id,rating})
        })
        const result=await response.json()
        setCurrentChat((state)=>
            state.map((msg)=>
                msg.messageId === message_id ? {...msg,rating: result.rating} : msg
            )
        )
    }

    const LoadingDots = () => {
        return (
          <div className="flex items-center justify-center space-x-1 mt-8 mb-8 w-4/5 mx-auto">
            <span className="w-4 h-4 bg-gray-500 rounded-full animate-bounce"></span>
            <span className="w-4 h-4 bg-gray-500 rounded-full animate-bounce delay-200"></span>
            <span className="w-4 h-4 bg-gray-500 rounded-full animate-bounce delay-400"></span>
          </div>
        );
    };

    const handleKeydown = (event: any) => {
        if (event.key === "Enter"){
            if (event.shiftKey) {
                event.preventDefault();
                setInput((prev)=>prev+'\n')
            } else {
                event.preventDefault();
                if (input.trim() !== "") {
                    getResponse(event); 
                }
            }
        }
    }

    const handleComment = (message_id:string,e:any) => {
        setCommentMessage((prev)=>({
            ...prev,
            [message_id]: e.target.value
        }))
    }

    const openCommentBox = async(message_id:string) => {
        const message_value=commentMessage[message_id]
        if (message_value !== ""){
            const response=await fetch('/api/saveComment',{
                method: "POST",
                headers: {
                    "Content-type":"application/json"
                },
                body: JSON.stringify({message_value, message_id})
            }) 
            const res=await response.json()
            if (res){
                setCommentMessage((prev)=>({
                    ...prev,
                    [message_id]:res.commentMessage
                }))
            }

        }
    }

    const isComment24hours=(commentAddedAt:Date|string|null)=>{
        if(!commentAddedAt){
            return false;
        }
        const commentDate=new Date(commentAddedAt)
        const now=new Date()
        const diff_time=now.getTime() - commentDate.getTime();
        const diffInHours=diff_time/(1000*60*60);
        return diffInHours > 24;

    }

    // bg-[rgb(222,233,235)]
    return (
        <div className="flex">
            <div className='flex bg-white'>
                <ChatHistory currentChat={currentChat} setCurrentChat={setCurrentChat} currChatId={currChatId} setCurrChatId={setCurrChatId} chatHistory={chatHistory} setChatHistory={setChatHistory}/>

                {status === "authenticated" &&
                <div className='flex flex-col' id='main'>
                        {/* <ChatLogs/> */}
                    <div className="chat-history overflow-auto overflow-y-auto flex-col justify-center">
                        {/* Loads all chat messages in chatHistory */}
                        
                        {currentChat.map((message, index) => {
                            const isAIMessage = message.sender === "AI"; // AI messages
                            const sources = extractSources(message.message); // Extract sources
                            const messageWithoutSources = message.message.split("\nSources:")[0];
                            const comment_date=message.commentAddedAt || null;
                            const comment_hrs=isComment24hours(comment_date)
                            return (
                                <div key={message.messageId || `chat-${index}`}  ref={index === currentChat.length - 1 ? currentChatRef : null} 
                                    className={`flex flex-row rounded-full ${isAIMessage ? 'bg-white w-4/5 mx-auto' : 'bg-[rgb(0,182,228)] text-white w-2/5 ml-auto pl-8 mr-[10%]'}`}>
                                    
                                    {/* User/AI Icon */}
                                    {isAIMessage && (
                                        <img src="/PA ICON.png" className="m-5 icon rounded" width="40" height="48" />
                                    )}
                                    
                                    {/* Message Content */}
                                    <div className='p-2 rounded message prose prose-sm max-w-none text-left'>
                                        <ReactMarkdown remarkPlugins={[remarkGfm]} className="markdown">{messageWithoutSources}</ReactMarkdown>

                                        {/* Display Sources (if available) */}
                                        {sources.length > 0 && (
                                            <div className="mt-4">
                                                <h4>Sources:</h4>
                                                <div className="source-links flex">
                                                    {sources.map((currSource, index) => (
                                                        <SourceLink url={currSource.url || ""} text={currSource.text || ""} index={index} key={index} />
                                                    ))}
                                                </div>
                                            </div>
                                        )}

                                        {/* Thumbs Up / Down Buttons (Only for AI Responses) */}
                                        {isAIMessage && index != 0 && (
                                            <div className='relative flex mt-6'>
                                                <button className={`py-1.5 px-3 mr-2 hover:text-green-600 hover:scale-105 hover:shadow border ${message.rating === 5? 'text-white bg-[rgb(216,22,113)]':'border-gray-300'} rounded-md h-8 text-sm flex items-center gap-1`}
                                                    data-id={`thumbs_up_${message.messageId}`} onClick={()=>updateRating(message.messageId,5)} disabled={message.rating === 5? true:false }>
                                                    <img src="/thumbsUp.svg" className='w-4' />
                                                </button>

                                                <button className={`py-1.5 px-3 mr-2 hover:text-red-600 hover:scale-105 hover:shadow border ${message.rating === 0? 'bg-[rgb(216,22,113)]':'border-gray-300'} rounded-md h-8 text-sm flex items-center gap-1`}
                                                    data-id={`thumbs_down_${message.messageId}`} onClick={()=>updateRating(message.messageId,0)} disabled={message.rating === 0? true:false }>
                                                    <img src="/thumbsDown.svg" className='w-4' />
                                                </button>
                                                {message.rating === 0 && <><input type="text" value={commentMessage[message.messageId] || message.reviewComments} onChange={(e) => handleComment(message.messageId,e)} id={`textInput_${index}`} className={`w-full px-3  resize-none rounded-md focus:outline-none bg-white border-2 border-[rgb(0,182,228)]-500 ${!comment_hrs? 'hover:shadow' : '' }`} placeholder='Help us improve by adding your review...'  autoComplete='off' disabled={comment_hrs ? true: false}/>
                                                {!comment_hrs && <button className={`absolute right-0 py-1.5 px-3 bg-[rgb(0,182,228)] hover:scale-105 hover:shadow border rounded-md h-8 text-sm flex items-center gap-1 text-white`}
                                                    data-id={`comment_${message.messageId}`} onClick={()=>openCommentBox(message.messageId)}>
                                                    <svg className="w-5 h-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="2" stroke="currentColor" >
                                                    <path strokeLinecap="round" strokeLinejoin="round" d="M8.625 12a.375.375 0 1 1-.75 0 .375.375 0 0 1 .75 0Zm0 0H8.25m4.125 0a.375.375 0 1 1-.75 0 .375.375 0 0 1 .75 0Zm0 0H12m4.125 0a.375.375 0 1 1-.75 0 .375.375 0 0 1 .75 0Zm0 0h-.375M21 12c0 4.556-4.03 8.25-9 8.25a9.764 9.764 0 0 1-2.555-.337A5.972 5.972 0 0 1 5.41 20.97a5.969 5.969 0 0 1-.474-.065 4.48 4.48 0 0 0 .978-2.025c.09-.457-.133-.901-.467-1.226C3.93 16.178 3 14.189 3 12c0-4.556 4.03-8.25 9-8.25s9 3.694 9 8.25Z" />
                                                    </svg>
                                                </button>}
                                                </>
                                                }
                                                
                                                
                                            </div>
                                        )}
                                    </div>
                                </div>
                            );
                        })}

                        {/* Puts a loading icon if API request is being made */}
                        {/* <LoadingSpinner loading={loading}/> */}
                        {loading &&  <LoadingDots />}
                        <div ref={currentChatRef}></div>
                        {message && <LoadingDots />}
                    </div>
                    
                    <div className='flex flex-start'>
                        <form onSubmit={getResponse} className='w-full flex flex-row justify-center items-center mt-4'>
                            
                            <div className="relative w-4/5">
                                <textarea  
                                    value={input} 
                                    onChange={e => setInput(e.target.value)} 
                                    id="textInput" 
                                    className='w-full px-4 py-3 resize-none h-19 rounded-xl focus:outline-none bg-white border-2 border-[rgb(0,182,228)]-500 hover:shadow' 
                                    placeholder='Ask me anything...'
                                    onKeyDown={handleKeydown}
                                />
                                {/* Send Button (Right Side) */}
                                <button 
                                    type="submit" 
                                    className="absolute right-12 top-2/3 transform -translate-y-1/2 text-white bg-[rgb(0,182,228)] 
                                            focus:ring-4 focus:outline-none focus:ring-blue-300 font-medium 
                                            rounded-full text-sm p-2 inline-flex items-center"
                                    disabled={sendDisabled}
                                >
                                    <svg className="w-5 h-5" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 14 10">
                                    <path stroke="currentColor" strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M1 5h12m0 0L9 1m4 4L9 9"/>
                                    </svg>
                                </button>

                                {/* Mic Button (Far Right Side) */}
                                <button 
                                    type='button' 
                                    className='absolute right-2 top-2/3 transform -translate-y-1/2 text-white bg-[rgb(0,182,228)] 
                                            font-medium rounded-full text-sm p-2' 
                                    onClick={startListening} 
                                    disabled={isListening}
                                > 
                                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-5 h-5 text-white">
                                    <path d="M12 2a3 3 0 00-3 3v7a3 3 0 106 0V5a3 3 0 00-3-3z" />
                                    <path fillRule="evenodd" d="M5 10a1 1 0 011 1v1a6 6 0 1012 0v-1a1 1 0 112 0v1a8 8 0 01-7 7.93V22a1 1 0 11-2 0v-2.07A8 8 0 015 12v-1a1 1 0 011-1z" clipRule="evenodd"/>
                                    </svg>
                                </button>
                            </div>
                        </form>
                    </div>
                    
                </div>
                }
		</div>
        </div>
    )

}
